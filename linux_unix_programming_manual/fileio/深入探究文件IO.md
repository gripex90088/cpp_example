### 深入探究文件IO

+ 原子
+ 多用途fcntl()，读取设置打开文件的状态标志
+ 了解用于表示文件描述符和已打开文件的内核数据结构
+ 学习一些支持扩展读写功能的系统调用， 在不改变文件当前偏移量的情况下，在文件的特定位置处进行读写操作，以及对程序中多个缓冲区进行数据(双向)传输
+ 非阻塞I/O概念



##### 原子操作和竞争条件

```
所有系统调用都是以原子操作方式执行的。内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断

原子性是某些操作得以圆满成功的关键所在。特别是它规避了竞争状态(race conditions)(有时也称为竞争冒险)。竞争状态：操作共享资源的两个进程(或线程),其结果取决于一个无法预期的顺序，即这些进程获得CPU使用权的先后相对顺序
```

##### 以独占方式创建一个文件

~~~
O_CREAT 和 O_EXCL标志来一次性地调用open(),确保检查文件内和创建文件的步骤属于一个单一的原子操作
~~~

##### 向文件尾部追加数据

```
规避数据写入被其他进程覆盖，需要将文件偏移量的移动与数据写操作纳入同一原子操作，在打开文件时加入O_APPEND标志保证这一点
```



##### 文件控制操作 fcntl()

```
#include <fcntl.h>

int fcntl(int fd, int cmd, ...);
								Return on success depends on cmd, or -1 on error
fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据cmd参数(如果有的话)的值来确定该参数的数据类型
```

##### 打开文件的标志状态

```
fcntl()的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志。要获取这些设置，将fcntl()的cmd参数设置为F_GETFL

int flags, accessMode;

flags = fcntl(fd, F_GETFL);
if (flags == -1)
	errExit("fcntl");

// 在之后，检查文件打开模式，  例如，测试文件是否以同步写方式
if (flags & O_SYNC)
	printf("writes are synchronized\n"); 
	
SUSv3规定: 针对一个打开的文件，只有通过open()或后续fcntl()的F_SETFL操作，才能对该文件的状态标志进行设置。然而，Linux实现与标准有所偏离:如果一个程序编译时采用了某些打开大文件技术，那么当使用F_GETFL命令获取文件状态时，标志中将总是包含O_LARGEFILE标志

判断文件的访问模式有一点复杂，因为O_RDONLY(0) O_WRONLY(1) O_RDWR(2)这三个常量并不与打开文件状态标志中的单个比特位对应。因此，要判定访问模式，需使用掩码O_ACCMODE与flag相与,将结果与3个常量进行比对
accessMode = flags & O_ACCMODE;
if (accessMode == O_WRONLY || accessMode == O_RDWR)
	printf("file is writable\n");

可以使用fcntl()的F_SETFL命令修改打开文件的某些状态标志。允许更改的标志有 O_APPEND, O_NONBLOCK, O_NOATIME, O_ASYNC, O_DIRECT。系统将忽略对其他标志的修改操作。(有些UNIX实现允许fcntl()修改其他标志，如O_SYNC)
使用fcntl()修改文件状态标志适用场景:
+ 文件不是由调用程序打开的，所以程序也无法使用open()调用来控制文件的状态(例如，文件是3个标准输入输出描述符中的一员，这些描述符在程序启动之前被打开)
+ 文件描述符的获取是通过open()之外的系统调用。比如pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。比如socket()调用，创建一个套接字并返回指向该套接字的文件描述符

为了修改打开文件的状态标志，可以使用fcntl()的F_GETFL命令来获取当前标志的副本，然后修改需要变更的比特位，最后再次调用fcntl()函数的F_SETFL命令来更新此状态标志。

例如，添加O_APPEND标志,
int flags;

flags = fcntl(fd, F_GETFL);
if (flags == -1)
	errExit("fcntl");
	
flags |= O_APPEND;
if (fcntl(fd, F_SETFEL, flags) == -1)
	errExit("fcntl");
```



##### 文件描述符和打开文件之间的关系

```
文件描述符和打开的文件之间似乎呈现一一对应的关系。然而，实际并非如此。多个文件描述符指向同一个打开文件，既有可能，也属必要，这些文件描述符可在相同或不同的进程打开

内核维护的3个数据结构
+ 进程级的文件描述符表
+ 系统级的打开文件表
+ 文件系统的i-node表

针对每个进程，内核为其维护打开文件的描述符(open file descriptor)表。该表中的每一条目都记录了单个文件描述符的相关信息,
+ 控制文件描述符操作的一组标志。(目前，此类标志仅定义了一个，即close-on-exec标志)
+ 对打开文件句柄的引用.

内核对所有打开的文件维护有一个系统级的描述表格(open file description table).有时,也称之为打开文件表(open file table),并将表中各条目称为打开文件句柄(open file handle).一个打开文件句柄存储了与一个打开文件相关的全部信息,
+ 当前文件偏移量(调用read()和write()时更新,或使用lseek()直接修改).
+ 打开文件时所使用的状态标志(即,open()的flags参数)
+ 文件访问模式(如调用open()时所设置的只读模式,只写模式或读写模式)
+ 对信号驱动I/O相关的设置
+ 对该文件i-node对象的引用

每个文件系统都会为驻留其上的所有文件建立一个i-node表,每个文件i-node信息
+ 文件类型(如,常规文件,套接字,FIFO)和访问权限
+ 一个指针,指向该文件所持有的锁的列表
+ 文件的各种属性,包括文件大小以及与不同类型操作相关的时间戳

此处将忽略i-node在磁盘和内存中的表示差异.磁盘上的i-node记录了文件的固有属性,诸如:文件类型,访问权限和时间戳.访问一个文件时,会在内存中为i-node创建一个副本,其中记录了引用该i-node的打开文件句柄数量以及该i-node所在设备的主,从设备号,还包括一些打开文件时与文件相关的临时属性,诸如:文件锁.

两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量(由调用read()、write()或lseek()所致)，那么从另一个文件描述中也会观察到这一变化
```

